
check delays match with paper (from when i wasraddr=waddr checking)

  // overall setup done on right clk cycle + using counter (matches IOen) -- hold setupdone
  // * memBanks (mem needs enable)
  // 3 multiplies
  // mem readen, test 100?, 3780
  // w0z
  // tilelink
  // check enable randomly turn off -- how affects? (maybe just bad output? but internally ok?) -- on all dspmodule pipes; check any regs in ctrl???

mode for running same data through many times for power


test that outvalid goes low on new setup


// rewrite tester
//** add to calc:






Load setup reg write to start setup reg. Prob for setup done (stay high) write to data in mem. Start frame = run for n clocks. Keep storing k , valid out, data out. After n clocks stop. Read out output. Input new data. Different input but without reset command (after original, pause). Read out again. Repeat. Check when valid. Increment frame after k = fft size-1. Repeat.

-- another mode where it's one at a time

** see recent email -- continue for power


TO MEM:

newCalcAddr


val eq2 = DSPBool(rad.toUInt === UInt(2))

val tempcurrRad = Mux(currentRadixD2 === UInt(2),UInt(4),currentRadixD2).toUInt

  Mux(numPower(3) === UInt(0),tempcurrRad,currentRadixD2)
  memBanks.io.currRad := Mux(numPower(3) === UInt(0),tempcurrRad,currentRadixD2)

  memBanks.io.calcAddr(i) := newCalcAddr(i).asOutput //calcAddr





  val rad2Dbl = (currentRadixD2.toUInt === UInt(2)).toBool & (numPower(0).toUInt =/= UInt(0)).toBool
  val newCalcAddr = Vec(calcAddr.zipWithIndex.map { case (e, i) => {
    val eNew = e.cloneType
    eNew := e.toUInt
    if (i == 2 || i == 3) {
      val temp = calcAddr(i - 2).cloneType
      temp := calcAddr(i - 2).toUInt
      Mux(rad2Dbl, temp, e).toUInt
    }
    else eNew
  }
  })
  debug(newCalcAddr)

