// TODO: Support IFFT, check signal limit (in double test -- need to implement ranging in double)

package FFT

import ChiselDSP._
import Chisel.{Complex => _, _}

import ChiselDSP.{Reg=>_,Mux=>_,when=>_,_}
import Chisel.{Complex => _, _}
import scala.collection.mutable.MutableList
import scala.language.reflectiveCalls

class FFTWrapper(fft_size : Int) extends Module {
  val io = new Bundle {
    val in  = Decoupled(Chisel.Complex(Dbl(OUTPUT), Dbl(OUTPUT))).flip
    val out = Valid(Chisel.Complex(Dbl(OUTPUT), Dbl(OUTPUT)))
  }

  val fft_name = "BasebandFFT"

  val cycle = Reg(init=UInt(0, width=64))
  cycle := cycle + UInt(1)

  val second_cycle_input_real = Reg(next=io.in.bits.real)
  val second_cycle_input_imag = Reg(next=io.in.bits.imag)

  val hold_second_cycle = Reg(init=Bool(false))

  val input_real = Mux(!hold_second_cycle, io.in.bits.real, second_cycle_input_real)
  val input_imag = Mux(!hold_second_cycle, io.in.bits.imag, second_cycle_input_imag)

  val saw_setup_done = Reg(init=Bool(false))
  val going = Reg(init=Bool(false))
  val outputting = Reg(init=Bool(false))
  val max_cycle = (1L << 63) - 1
  val end_cycle_input = Reg(init=UInt(max_cycle, width=64))
  val end_cycle_output = Reg(init=UInt(max_cycle, width=64))
  val go = saw_setup_done && !hold_second_cycle && io.in.valid && !going && !outputting
  val hold_go = Reg(next=go)

  FFTGenerator()
  val p = GeneratorParams(
    fft = FFTParams(sizes = List(3,4,5,16)),//,2048)),
    complex = ComplexParams(
      mulPipe       = 1,
      intBits       = 4,
      fracBits      = 12,
      use4Muls      = true,
      addPipe       = 0,
      trimType      = Truncate,
      overflowType  = Grow,
      mulFracGrowth = 3
    )
  )
  println(p)
  Init(p, Array("-params_TRUE"))
  Params(p)
  val fft = DSPModule(new FFT({DSPDbl()}), fft_name)

  fft.io.DATA_IN.real := chiselCast(input_real){DSPDbl(input_real.dir)}
  fft.io.DATA_IN.imag := chiselCast(input_imag){DSPDbl(input_real.dir)}
  fft.io.SETUP_INIT := cycle === UInt(1) || cycle === UInt(2) //|| cycle === UInt(3)
  val size_idx = Params.getFFT.sizes.indexOf(fft_size)
  fft.io.FFT_INDEX  := UInt(size_idx)
  fft.io.FFT        := UInt(1)
  fft.io.START_FIRST_FRAME := go || hold_go

  io.out.bits.real := chiselCast(fft.io.DATA_OUT.real){Dbl(fft.io.DATA_OUT.real.dir)}
  io.out.bits.imag := chiselCast(fft.io.DATA_OUT.imag){Dbl(fft.io.DATA_OUT.imag.dir)}

  when (cycle > UInt(2) && fft.io.SETUP_DONE) {
    saw_setup_done := Bool(true)
  }

  printf("GO: %d\n", go)
  printf("GO: %d\n", hold_go)
  printf("GOING: %d\n", going)
  printf("CYCLE: %d\n", cycle)
  printf("FIRSTOUT: %d\n", fft.io.FIRST_OUT)
  printf("OUTPUTTING: %d\n", outputting)

  when (go) {
    going := Bool(true)
    end_cycle_input := cycle + UInt(2 * fft_size)
  }
  when (go || going || outputting) {
    hold_second_cycle := !hold_second_cycle
  }
  when (cycle >= end_cycle_input) {
    going             := Bool(false)
  }
  when (fft.io.FIRST_OUT && !outputting) {
    outputting        := Bool(true)
    end_cycle_input := cycle + UInt(10 * fft_size + 7) //UInt(10 * fft_size + 7)
    end_cycle_output := cycle + UInt(fft_size * 10 + 7)
  }
  when (cycle >= end_cycle_output) {
    hold_second_cycle := Bool(false)
    outputting := Bool(false)
    end_cycle_input  := UInt(max_cycle)
    end_cycle_output := UInt(max_cycle)
  }

  io.in.ready  := (going && !hold_second_cycle) || (!going && !outputting && cycle > UInt(2) && saw_setup_done)
  io.out.valid := outputting && hold_second_cycle
}

/** Module tester that allows switching between fixed and floating point testing **/
class FFTTests2[T <: FFT[_ <: DSPQnm[_]]](c: T, inputs : Seq[ScalaComplex], fft_size : Int, outputs : MutableList[ScalaComplex]) extends DSPTester(c) {
  traceOn = false
  // Set tolerance for comparing expected values
  DSPTester.setTol(floTol = 0.00000001,fixedTol = (Complex.getFrac/3).toInt)

  // break input arrays up into groups of fft_size (pad zeros if too short)
  val grouped_inputs = inputs grouped(fft_size ) map {x =>
    x ++ Seq.fill(fft_size - x.length){new ScalaComplex(0.0,0.0)}
  }
  for (input <- grouped_inputs) {
    run(input)
  }
  // surely there must be a better way...
  val outputs_ = outputs.zipWithIndex.collect {case(elem, idx) if idx % 2 == 0 => elem}
  outputs.clear()
  outputs ++= outputs_

  /** Run tests for desired FFTN */
  def run(in : Seq[ScalaComplex]) : Seq[ScalaComplex] = {
    val n = in.length
    val idxN = Params.getFFT.sizes.indexOf(n)

    Tracker.reset(n)
    if (traceOn) Status("FFTN = " + n)
    if (idxN < 0) Error("FFTN is not included in this generated output")

    testFFTNio(idxN, fftTF = true, in)
  }

  def newSetup(fftIndex:Int, fftTF:Boolean) : Unit = {
    println("///////////////////////////////////////// NEW SETUP")
    poke(c.io.SETUP_INIT,true)
    poke(c.io.FFT_INDEX,fftIndex)
    poke(c.io.FFT,fftTF)
    step(1)
    poke(c.io.SETUP_INIT,true)
    poke(c.io.FFT_INDEX,fftIndex)
    poke(c.io.FFT,fftTF)
    step(1)
    poke(c.io.SETUP_INIT,false)
    var doneFlag = peek(c.io.SETUP_DONE)
    while (!doneFlag){
      step(1)
      doneFlag = peek(c.io.SETUP_DONE)
    }
    // Wait until done setting up
    readSetupConstants(fftIndex,1)
  }

  def readSetupConstants(fftIndex:Int, exitTF:Int) : Unit = {
    expect(c.fftIndex,fftIndex)
    expect(c.fftTF,true)
    expect(c.numPower,generalConstants.numPowerArray(fftIndex))
    expect(c.coprimes,generalConstants.coprimesArray(fftIndex))
    expect(c.coprimesFlipped,generalConstants.coprimesArray(fftIndex).reverse)
    expect(c.twiddleCount,twiddleConstants.twiddleCountMaxArray(fftIndex))
    peek(c.stageSum)
    peek(c.maxRadix)
    peek(c.twiddleSubCountMax)
    peek(c.radNTwiddleMul)
    peek(c.stageRadix)
    peek(c.maxStageCount)
    peek(c.addressConstant)
    peek (c.twiddleMul)
    peek(c.io.SETUP_DONE)
    println("\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ SETUP DONE")
  }



  def testFFTNio(fftIndex:Int, fftTF:Boolean, in1:Seq[ScalaComplex]) : Seq[ScalaComplex] = {
    println("\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ TEST FFT N" + Tracker.FFTN)
    newSetup(fftIndex,fftTF)

    step(1)
    poke(c.io.START_FIRST_FRAME,true)
    stepP(1, in1)
    poke(c.io.START_FIRST_FRAME,true)
    stepP(1, in1)
    poke(c.io.START_FIRST_FRAME,false)
    // Continue checking for a few counts after full 2x FFT size (slow clk takes twice as long as fast clock) -- both phases
    for (i <- 0 until 5){
      for (i <- 0 until 2*Params.getFFT.sizes(fftIndex)){
        outputs ++= stepP(1, in1)
      }
    }
    for (i <- 0 until 7){										// Back to A
      outputs ++= stepP(1, in1)
    }
    outputs.toList
  }

  // Always peek signals before stepping
  def stepP(num:Int, in1:Seq[ScalaComplex]) : Seq[ScalaComplex] = {

    // Every other time function is executed, change input data (IO "clock" slow)
    val stepInC:Int = (Tracker.inStep)
    val indexIn:Int = math.floor(stepInC/2).toInt
    val in = if (indexIn < in1.length) in1(indexIn) else new ScalaComplex(0,0) // pad with zeros
    println("//IndexIn:\t" + indexIn)
    val outputs = new MutableList[ScalaComplex]()
    poke(c.io.DATA_IN, in)

    //** Starts counting cycle after START_FIRST_FRAME asserted

    //traceOn = true

    val start_symbol = peek(c.io.FIRST_OUT)					    // k,n = 0 IO

    if (start_symbol && !Tracker.startSymbol){
      println("/////////////////////////// k = 0 Symbol Start ///////////////////////////")
      Tracker.outValid = true							// Output valid
    }
    Tracker.startSymbol = start_symbol  // Save old value

    traceOn = false

    if (Tracker.outValid) {
      val stepOutC:Int = (Tracker.outStep)
      val indexOut = math.floor(stepOutC/2).toInt
      Tracker.outStep = Tracker.outStep + 1
      val errorString = "\n  FFTN = " + Tracker.FFTN + "\n  k = " + indexOut%Tracker.FFTN
      if(indexOut < fft_size) outputs += peek(c.io.DATA_OUT)
    }
    Tracker.inStep =  Tracker.inStep + 1
    step(num)
    outputs





  }


  /*

  /** Run all tests for all FFTNs */
  def runAll() : Unit = runTo(Params.getFFT.sizes.last)

  /** Run for all FFT sizes until (and including) N */
  def runTo(n: Int): Unit = {
    reset()
    val sizes = Params.getFFT.sizes
    val idx = sizes.indexOf(n)
    for (i <- 0 to idx) run(sizes(i))
  }

  /** Run tests for desired FFTN */
  def run(n: Int) : Unit = {
    Tracker.reset(n)
    if (traceOn) Status("FFTN = " + n)
    stepThrough(n)
  }

  /** Step through test vectors for FFTN */
  def stepThrough(n: Int): Unit = {
    val idxN = Params.getFFT.sizes.indexOf(n)
    if (idxN < 0) Error("FFTN is not included in this generated output")
    val inVec = TestVectors.getIn(idxN)
    val outVec = TestVectors.getOut(idxN)

    //println(inVec)
    //println(outVec)
    // TODO: Clean
    testFFTNio(idxN, fftTF = true, inVec,outVec)
    /*
    butterflyTest(inVec,outVec,calcDIT=true)
    butterflyTest(inVec,outVec,calcDIT=false)
    testMem(inVec)
    */
  }

   */
}



}

object Tracker {

  // Variables to track tester progress
  var startSymbol = false
  var outValid = false
  var inStep = 0
  var outStep = 0
  var FFTN = 0

  // Reset variables on new test
  def reset(n: Int) : Unit = {
    startSymbol = false
    outValid = false
    inStep = 0
    outStep = 0
    FFTN = n
  }
}